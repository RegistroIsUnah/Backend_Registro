
Use sistemaregistro1;

DELIMITER //

CREATE PROCEDURE SP_insertarAspirante(
    IN p_nombre VARCHAR(100),
    IN p_apellido VARCHAR(100),
    IN p_documento VARCHAR(50),
    IN p_telefono VARCHAR(20),
    IN p_correo VARCHAR(100),
    IN p_foto VARCHAR(255),
    IN p_fotodni VARCHAR(255),
    IN p_carrera_principal_id INT,
    IN p_carrera_secundaria_id INT,
    IN p_centro_id INT,
    IN p_certificado_url VARCHAR(255),
    IN p_tipo_documento_id INT
)
BEGIN
    DECLARE v_numSolicitud VARCHAR(50);
    DECLARE v_estado_aspirante_id INT;

    -- Verificar si ya existe un aspirante con el mismo documento
    IF (SELECT COUNT(*) FROM Aspirante WHERE documento = p_documento) > 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'El aspirante ya ha sido inscrito';
    END IF;
    
    -- Obtener el estado_aspirante_id para 'PENDIENTE'
    SELECT estado_aspirante_id INTO v_estado_aspirante_id
    FROM EstadoAspirante
    WHERE nombre = 'PENDIENTE';

    -- Si no existe, crear el estado 'PENDIENTE'
    IF v_estado_aspirante_id IS NULL THEN
        INSERT INTO EstadoAspirante (nombre) VALUES ('PENDIENTE');
        SET v_estado_aspirante_id = LAST_INSERT_ID();
    END IF;

    -- Generar el número de solicitud con prefijo 'SOL-' y 10 caracteres aleatorios
    SET v_numSolicitud = CONCAT('SOL-', 
        UPPER(CONCAT(
            SUBSTRING('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', FLOOR(RAND() * 36) + 1, 1),
            SUBSTRING('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', FLOOR(RAND() * 36) + 1, 1),
            SUBSTRING('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', FLOOR(RAND() * 36) + 1, 1),
            SUBSTRING('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', FLOOR(RAND() * 36) + 1, 1),
            SUBSTRING('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', FLOOR(RAND() * 36) + 1, 1),
            SUBSTRING('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', FLOOR(RAND() * 36) + 1, 1),
            SUBSTRING('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', FLOOR(RAND() * 36) + 1, 1),
            SUBSTRING('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', FLOOR(RAND() * 36) + 1, 1),
            SUBSTRING('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', FLOOR(RAND() * 36) + 1, 1),
            SUBSTRING('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', FLOOR(RAND() * 36) + 1, 1)
        ))
    );

    -- Insertar en la tabla Aspirante
    INSERT INTO Aspirante (
        nombre, apellido, documento, telefono, correo, foto, fotodni, numSolicitud,
        carrera_principal_id, carrera_secundaria_id, centro_id, certificado_url,
        estado_aspirante_id, tipo_documento_id, fecha_solicitud
    ) VALUES (
        p_nombre, p_apellido, p_documento, p_telefono, p_correo, p_foto, p_fotodni, v_numSolicitud,
        p_carrera_principal_id, p_carrera_secundaria_id, p_centro_id, p_certificado_url,
        v_estado_aspirante_id, p_tipo_documento_id, CURDATE()
    );
    
    -- Devolver el número de solicitud generado
    SELECT v_numSolicitud AS numSolicitud;
END //

DELIMITER ;




DELIMITER //

CREATE PROCEDURE SP_asignarUsuarioDocente(
    IN p_docente_id INT,
    IN p_username VARCHAR(100),
    IN p_password VARCHAR(100)
)
BEGIN
    DECLARE v_rol_id INT;
    DECLARE v_usuario_id INT;

    -- Verificar que el docente exista y que aún no tenga usuario asignado
    IF (SELECT COUNT(*) FROM Docente WHERE docente_id = p_docente_id AND usuario_id IS NOT NULL) > 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'El docente ya tiene credenciales asignadas';
    END IF;

    -- Obtener el rol "docente"
    SELECT rol_id INTO v_rol_id FROM Rol WHERE nombre = 'docente' LIMIT 1;
    IF v_rol_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Rol docente no encontrado en el sistema';
    END IF;

    -- Insertar el nuevo usuario en la tabla Usuario
    INSERT INTO Usuario (username, password, rol_id)
    VALUES (p_username, p_password, v_rol_id);
    
    -- Obtener el ID del usuario recién insertado
    SET v_usuario_id = LAST_INSERT_ID();
    
    -- Actualizar el registro del docente para asignarle el usuario
    UPDATE Docente
    SET usuario_id = v_usuario_id
    WHERE docente_id = p_docente_id;
    
    -- Retornar mensaje de éxito
    SELECT 'Credenciales correctamente asignadas' AS mensaje;
END //

DELIMITER ;


DELIMITER //

CREATE PROCEDURE SP_crearSeccion(
    IN p_clase_id INT,
    IN p_docente_id INT,
    IN p_periodo_academico_id INT,
    IN p_aula_id INT,
    IN p_hora_inicio TIME,
    IN p_hora_fin TIME,
    IN p_cupos INT,
    IN p_dias VARCHAR(255),  -- Cadena de días separados por comas (ej: "1,2,3")
    IN p_video_url VARCHAR(255) DEFAULT NULL  -- Parámetro ahora opcional
)
BEGIN
    DECLARE v_creditos INT;
    DECLARE v_duracion DECIMAL(5,2);
    DECLARE v_numDias INT;
    DECLARE v_totalDays INT;
    DECLARE v_counter INT DEFAULT 1;
    DECLARE v_day INT;
    DECLARE v_section_id INT;
    DECLARE v_estado_proceso VARCHAR(30);
    DECLARE v_capacidad_aula INT;
    DECLARE v_estado_seccion VARCHAR(20);

    -- Validar parámetros obligatorios
    IF p_clase_id IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El ID de la clase no puede estar vacío';
    END IF;

    IF p_docente_id IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El ID del docente no puede estar vacío';
    END IF;

    -- Verificar que el período académico esté activo (usando nombre en lugar de ID)
    SELECT ep.nombre INTO v_estado_proceso
    FROM PeriodoAcademico pa
    JOIN EstadoProceso ep ON pa.estado_proceso_id = ep.estado_proceso_id
    WHERE pa.periodo_academico_id = p_periodo_academico_id;

    IF v_estado_proceso <> 'ACTIVO' THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El período académico no está activo';
    END IF;

    -- Verificar que la hora de inicio sea menor a la de fin
    IF p_hora_inicio >= p_hora_fin THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'La hora de inicio debe ser menor a la hora de fin';
    END IF;

    -- Obtener créditos de la clase
    SELECT creditos INTO v_creditos FROM Clase WHERE clase_id = p_clase_id;
    IF v_creditos IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Clase no encontrada';
    END IF;

    -- Verificar capacidad del aula
    SELECT capacidad INTO v_capacidad_aula FROM Aula WHERE aula_id = p_aula_id;
    IF v_capacidad_aula IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Aula no encontrada';
    END IF;
    
    IF p_cupos > v_capacidad_aula THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = CONCAT('Los cupos (', p_cupos, ') exceden la capacidad del aula (', v_capacidad_aula, ')');
    END IF;

    -- Calcular duración en horas
    SET v_duracion = (TIME_TO_SEC(p_hora_fin) - TIME_TO_SEC(p_hora_inicio)) / 3600;

    -- Calcular número de días recibido (cadena separada por comas)
    IF p_dias = '' THEN
        SET v_numDias = 0;
    ELSE
        SET v_numDias = LENGTH(p_dias) - LENGTH(REPLACE(p_dias, ',', '')) + 1;
    END IF;
    SET v_totalDays = v_numDias;

    IF v_totalDays = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Debe especificarse al menos un día';
    END IF;

    -- Validar la regla según la cantidad de días y créditos:
    IF v_totalDays > 1 THEN
        IF v_totalDays <> v_creditos THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El número de días no coincide con los créditos de la clase';
        END IF;
        IF ABS(v_duracion - 1) > 0.01 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Para secciones en varios días, cada sesión debe durar 1 hora';
        END IF;
    ELSEIF v_totalDays = 1 THEN
        IF ABS(v_duracion - v_creditos) > 0.01 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Para secciones en un solo día, la duración total debe ser igual a los créditos de la clase';
        END IF;
    END IF;

    -- Verificar traslapes en el aula y traslapes en el docente para cada día
    SET v_counter = 1;
    WHILE v_counter <= v_totalDays DO
        SET v_day = CAST(TRIM(SUBSTRING_INDEX(SUBSTRING_INDEX(p_dias, ',', v_counter), ',', -1)) AS UNSIGNED);

        -- Verificar traslape en el aula (usando nombre de estado en lugar de ID)
        IF EXISTS (
            SELECT 1
            FROM Seccion s
            JOIN SeccionDia sd ON s.seccion_id = sd.seccion_id
            JOIN EstadoSeccion es ON s.estado_seccion_id = es.estado_seccion_id
            WHERE s.aula_id = p_aula_id
              AND sd.dia_id = v_day
              AND s.periodo_academico_id = p_periodo_academico_id
              AND es.nombre = 'ACTIVA'
              AND (TIME_TO_SEC(p_hora_inicio) < TIME_TO_SEC(s.hora_fin)
                   AND TIME_TO_SEC(p_hora_fin) > TIME_TO_SEC(s.hora_inicio))
        ) THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Conflicto de horario en el aula para el día especificado';
        END IF;

        -- Verificar traslape en el docente (usando nombre de estado en lugar de ID)
        IF EXISTS (
            SELECT 1
            FROM Seccion s
            JOIN SeccionDia sd ON s.seccion_id = sd.seccion_id
            JOIN EstadoSeccion es ON s.estado_seccion_id = es.estado_seccion_id
            WHERE s.docente_id = p_docente_id
              AND sd.dia_id = v_day
              AND s.periodo_academico_id = p_periodo_academico_id
              AND es.nombre = 'ACTIVA'
              AND (TIME_TO_SEC(p_hora_inicio) < TIME_TO_SEC(s.hora_fin)
                   AND TIME_TO_SEC(p_hora_fin) > TIME_TO_SEC(s.hora_inicio))
        ) THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El docente ya tiene una sección asignada en ese horario para el día especificado';
        END IF;

        SET v_counter = v_counter + 1;
    END WHILE;

    -- Obtener ID del estado "ACTIVA" para la inserción
    SELECT estado_seccion_id INTO v_estado_seccion
    FROM EstadoSeccion
    WHERE nombre = 'ACTIVA';
    
    IF v_estado_seccion IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'No se encontró el estado ACTIVA en la tabla EstadoSeccion';
    END IF;

    -- Insertar la sección (incluyendo cupos)
    INSERT INTO Seccion (
        clase_id, docente_id, periodo_academico_id, hora_inicio, hora_fin, 
        aula_id, estado_seccion_id, cupos, video_url
    )
    VALUES (
        p_clase_id, p_docente_id, p_periodo_academico_id, p_hora_inicio, 
        p_hora_fin, p_aula_id, v_estado_seccion, p_cupos, p_video_url
    );
    SET v_section_id = LAST_INSERT_ID();

    -- Insertar cada día en la tabla SeccionDia
    SET v_counter = 1;
    WHILE v_counter <= v_totalDays DO
        SET v_day = CAST(TRIM(SUBSTRING_INDEX(SUBSTRING_INDEX(p_dias, ',', v_counter), ',', -1)) AS UNSIGNED);
        INSERT INTO SeccionDia (seccion_id, dia_id) VALUES (v_section_id, v_day);
        SET v_counter = v_counter + 1;
    END WHILE;

    -- Devolver el ID de la sección creada
    SELECT v_section_id AS seccion_id;
END //

DELIMITER ;


DELIMITER //

CREATE PROCEDURE SP_modificarSeccion(
    IN p_seccion_id INT,
    IN p_docente_id INT DEFAULT NULL,          -- Parámetro opcional
    IN p_aula_id INT DEFAULT NULL,             -- Parámetro opcional
    IN p_estado VARCHAR(20) DEFAULT NULL,      -- 'ACTIVA' o 'CANCELADA'
    IN p_motivo_cancelacion TEXT DEFAULT NULL, -- Obligatorio si p_estado es 'CANCELADA'
    IN p_cupos INT DEFAULT NULL,               -- Para actualizar cupos
    IN p_video_url VARCHAR(255) DEFAULT NULL   -- Ahora es opcional
)
BEGIN
    DECLARE v_estado_seccion_id INT;
    DECLARE v_capacidad_aula INT;
    DECLARE v_hora_inicio TIME;
    DECLARE v_hora_fin TIME;
    DECLARE v_periodo_academico_id INT;
    DECLARE v_dias_seccion VARCHAR(255);
    DECLARE v_current_aula_id INT;
    DECLARE v_current_docente_id INT;
    
    -- Validar parámetros obligatorios
    IF p_seccion_id IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El ID de la sección no puede estar vacío';
    END IF;

    -- Obtener información actual de la sección para validaciones
    SELECT 
        s.hora_inicio, s.hora_fin, s.periodo_academico_id, 
        s.aula_id, s.docente_id,
        GROUP_CONCAT(sd.dia_id ORDER BY sd.dia_id SEPARATOR ',')
    INTO 
        v_hora_inicio, v_hora_fin, v_periodo_academico_id,
        v_current_aula_id, v_current_docente_id,
        v_dias_seccion
    FROM Seccion s
    LEFT JOIN SeccionDia sd ON s.seccion_id = sd.seccion_id
    WHERE s.seccion_id = p_seccion_id
    GROUP BY s.seccion_id;
    
    IF v_hora_inicio IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Sección no encontrada';
    END IF;

    -- Validar capacidad del aula si se cambian cupos o aula
    IF p_cupos IS NOT NULL OR p_aula_id IS NOT NULL THEN
        -- Determinar qué aula verificar (la nueva o la actual)
        SET v_current_aula_id = COALESCE(p_aula_id, v_current_aula_id);
        
        SELECT capacidad INTO v_capacidad_aula 
        FROM Aula 
        WHERE aula_id = v_current_aula_id;
        
        IF p_cupos IS NOT NULL AND p_cupos > v_capacidad_aula THEN
            SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = CONCAT('Los cupos (', p_cupos, ') exceden la capacidad del aula (', v_capacidad_aula, ')');
        END IF;
    END IF;

    -- Si se intenta cancelar, se requiere un motivo de cancelación
    IF p_estado = 'CANCELADA' AND (p_motivo_cancelacion IS NULL OR TRIM(p_motivo_cancelacion) = '') THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Debe proporcionar motivo de cancelación';
    END IF;

    -- Obtener el estado_seccion_id correspondiente al nombre proporcionado
    IF p_estado IS NOT NULL THEN
        SELECT estado_seccion_id INTO v_estado_seccion_id
        FROM EstadoSeccion
        WHERE nombre = p_estado;
        
        IF v_estado_seccion_id IS NULL THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Estado de sección inválido. Use ACTIVA o CANCELADA';
        END IF;
    END IF;

    -- Validar conflictos de horario si se cambia aula o docente
    IF p_aula_id IS NOT NULL OR p_docente_id IS NOT NULL THEN
        -- Determinar qué aula y docente verificar (los nuevos o los actuales)
        SET v_current_aula_id = COALESCE(p_aula_id, v_current_aula_id);
        SET v_current_docente_id = COALESCE(p_docente_id, v_current_docente_id);
        
        -- Verificar conflictos para cada día de la sección
        IF EXISTS (
            SELECT 1
            FROM Seccion s
            JOIN SeccionDia sd ON s.seccion_id = sd.seccion_id
            JOIN EstadoSeccion es ON s.estado_seccion_id = es.estado_seccion_id
            WHERE ((p_aula_id IS NOT NULL AND s.aula_id = v_current_aula_id) OR 
                   (p_docente_id IS NOT NULL AND s.docente_id = v_current_docente_id))
              AND s.seccion_id != p_seccion_id
              AND s.periodo_academico_id = v_periodo_academico_id
              AND es.nombre = 'ACTIVA'
              AND FIND_IN_SET(sd.dia_id, v_dias_seccion) > 0
              AND (TIME_TO_SEC(v_hora_inicio) < TIME_TO_SEC(s.hora_fin) AND 
                   TIME_TO_SEC(v_hora_fin) > TIME_TO_SEC(s.hora_inicio))
        ) THEN
            SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = 'Conflicto de horario con otra sección activa';
        END IF;
    END IF;

    -- Actualizar la sección con los nuevos valores
    UPDATE Seccion
    SET 
        docente_id = COALESCE(p_docente_id, docente_id),
        aula_id = COALESCE(p_aula_id, aula_id),
        estado_seccion_id = COALESCE(v_estado_seccion_id, estado_seccion_id),
        motivo_cancelacion = CASE 
            WHEN p_estado = 'CANCELADA' THEN p_motivo_cancelacion
            WHEN p_estado = 'ACTIVA' THEN NULL -- Limpiar motivo si se reactiva
            ELSE motivo_cancelacion
        END,
        cupos = COALESCE(p_cupos, cupos),
        video_url = COALESCE(p_video_url, video_url)
    WHERE seccion_id = p_seccion_id;

    -- Si no se actualizó ninguna fila, se lanza un error
    IF ROW_COUNT() = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'No se realizaron cambios en la sección';
    END IF;
END //

DELIMITER ;



DELIMITER //

CREATE PROCEDURE SP_matricular_estudiante_viejo(
    IN p_estudiante_id INT,
    IN p_seccion_id INT,
    IN p_tipo_proceso_nombre VARCHAR(50),
    IN p_laboratorio_id INT
)
BEGIN
    -- Declaración de variables
    DECLARE v_proceso_id INT;
    DECLARE v_periodo_academico_id INT;
    DECLARE v_fecha_inicio DATETIME;
    DECLARE v_estado_proceso_id INT;
    DECLARE v_indice_global DECIMAL(5,2);
    DECLARE v_diaMatricula INT;
    DECLARE v_rango_min DECIMAL(5,2);
    DECLARE v_rango_max DECIMAL(5,2);
    DECLARE v_cupos INT;
    DECLARE v_totalMatriculados INT;
    DECLARE v_estadoMatricula VARCHAR(20);
    DECLARE v_orden_inscripcion INT DEFAULT NULL;
    DECLARE v_requisito INT;
    DECLARE v_cumpleRequisito INT;
    DECLARE v_matricula_id INT;
    DECLARE v_tipo_proceso_id INT;
    DECLARE v_tiene_lab BOOLEAN;
    DECLARE v_seccion_clase_id INT;
    DECLARE v_seccion_hora_inicio TIME;
    DECLARE v_seccion_hora_fin TIME;
    DECLARE v_seccion_dias VARCHAR(100);
    DECLARE v_lab_hora_inicio TIME;
    DECLARE v_lab_hora_fin TIME;
    DECLARE v_lab_dias VARCHAR(100);
    DECLARE v_creditos_seccion INT;
    DECLARE v_total_creditos INT;
    
    -- 1. Verificar tipo de proceso y obtener su ID
    SELECT tipo_proceso_id INTO v_tipo_proceso_id 
    FROM TipoProcesoMatricula 
    WHERE UPPER(nombre) = UPPER(p_tipo_proceso_nombre);
    
    IF v_tipo_proceso_id IS NULL THEN
       SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Tipo de proceso no válido. Debe ser MATRICULA o ADICIONES_CANCELACIONES';
    END IF;

    -- 2. Obtener proceso activo para el tipo especificado
    SELECT pm.proceso_id, pm.periodo_academico_id, pm.fecha_inicio, pm.estado_proceso_id
    INTO v_proceso_id, v_periodo_academico_id, v_fecha_inicio, v_estado_proceso_id
    FROM ProcesoMatricula pm
    WHERE pm.tipo_proceso_id = v_tipo_proceso_id
      AND pm.estado_proceso_id = (SELECT estado_proceso_id FROM EstadoProceso WHERE nombre = 'ACTIVO')
    LIMIT 1;
    
    IF v_proceso_id IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'No hay proceso activo para el tipo especificado';
    END IF;
    
    -- Verificar que la sección pertenece al periodo académico del proceso activo
    IF NOT EXISTS (
        SELECT 1 FROM Seccion 
        WHERE seccion_id = p_seccion_id 
        AND periodo_academico_id = v_periodo_academico_id
    ) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'La sección no pertenece al periodo académico activo';
    END IF;
    
    -- Verificar que la sección está activa
    IF NOT EXISTS (
        SELECT 1 FROM Seccion 
        WHERE seccion_id = p_seccion_id 
        AND estado_seccion_id = (SELECT estado_seccion_id FROM EstadoSeccion WHERE nombre = 'ACTIVA')
    ) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'La sección no está activa';
    END IF;
    
    -- 3. Validar estudiante
    SELECT indice_global INTO v_indice_global FROM Estudiante WHERE estudiante_id = p_estudiante_id;
    IF v_indice_global IS NULL THEN
       SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Estudiante no encontrado';
    END IF;

    -- 4. Solo verificar índice si es proceso de MATRICULA
    IF UPPER(p_tipo_proceso_nombre) = 'MATRICULA' THEN
        SET v_diaMatricula = FLOOR((UNIX_TIMESTAMP(NOW()) - UNIX_TIMESTAMP(v_fecha_inicio)) / 86400) + 1;
           
        IF v_diaMatricula = 1 THEN
           SET v_rango_min = 80; SET v_rango_max = 100;
        ELSEIF v_diaMatricula = 2 THEN
           SET v_rango_min = 60; SET v_rango_max = 79;
        ELSEIF v_diaMatricula = 3 THEN
           SET v_rango_min = 0; SET v_rango_max = 59;
        ELSE
           SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Día de matrícula no definido';
        END IF;
           
        IF v_indice_global < v_rango_min OR v_indice_global > v_rango_max THEN
           SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El índice global no corresponde al día de matrícula actual';
        END IF;
    END IF;
    
    -- 5. Verificar requisitos previos
    SET v_requisito = NULL;
    SET v_cumpleRequisito = 0;
    
    SELECT prerequisito_clase_id INTO v_requisito FROM ClaseRequisito 
      WHERE clase_id = (SELECT clase_id FROM Seccion WHERE seccion_id = p_seccion_id)
      LIMIT 1;
      
    IF v_requisito IS NOT NULL THEN
       SELECT COUNT(*) INTO v_cumpleRequisito FROM HistorialEstudiante 
         WHERE estudiante_id = p_estudiante_id 
           AND seccion_id IN (SELECT seccion_id FROM Seccion WHERE clase_id = v_requisito)
           AND estado_curso_id = (SELECT estado_curso_id FROM EstadoCurso WHERE nombre = 'APROBADA');
       IF v_cumpleRequisito = 0 THEN
          SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El estudiante no cumple el requisito previo para la clase';
       END IF;
    END IF;
    
    -- Verificar que el estudiante no está ya matriculado en esta sección
    IF EXISTS (
        SELECT 1 FROM Matricula 
        WHERE estudiante_id = p_estudiante_id 
        AND seccion_id = p_seccion_id
        AND estado_matricula_id IN (
            SELECT estado_matricula_id FROM EstadoMatricula 
            WHERE nombre IN ('MATRICULADO', 'EN ESPERA')
        )
    ) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El estudiante ya está matriculado en esta sección';
    END IF;
    
    -- Verificar límite de créditos (25 máximo) - Solo secciones (clases), laboratorios no suman créditos
    -- Obtener créditos de la sección actual
    SELECT c.creditos INTO v_creditos_seccion 
    FROM Clase c
    JOIN Seccion s ON c.clase_id = s.clase_id
    WHERE s.seccion_id = p_seccion_id;
    
    -- Calcular créditos actuales del estudiante en el periodo (solo secciones)
    SELECT IFNULL(SUM(c.creditos), 0) INTO v_total_creditos
    FROM Matricula m
    JOIN Seccion s ON m.seccion_id = s.seccion_id
    JOIN Clase c ON s.clase_id = c.clase_id
    WHERE m.estudiante_id = p_estudiante_id
    AND s.periodo_academico_id = v_periodo_academico_id
    AND m.estado_matricula_id IN (
        SELECT estado_matricula_id FROM EstadoMatricula 
        WHERE nombre IN ('MATRICULADO', 'EN ESPERA')
    );
    
    -- Verificar si supera el límite con esta nueva matrícula
    IF (v_total_creditos + v_creditos_seccion) > 25 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'La matrícula excede el límite de 25 créditos';
    END IF;
    
    -- Obtener horarios de la sección principal
    SELECT hora_inicio, hora_fin INTO v_seccion_hora_inicio, v_seccion_hora_fin 
    FROM Seccion WHERE seccion_id = p_seccion_id;
    
    -- Obtener días de la sección principal
    SELECT GROUP_CONCAT(d.nombre ORDER BY d.nombre SEPARATOR ',') INTO v_seccion_dias
    FROM SeccionDia sd
    JOIN DiaSemana d ON sd.dia_id = d.dia_id
    WHERE sd.seccion_id = p_seccion_id;
    
    -- 6. Verificar traslapes para la sección principal
    IF EXISTS (
        SELECT 1 FROM Matricula m
        JOIN Seccion s ON m.seccion_id = s.seccion_id OR m.laboratorio_id = s.laboratorio_id
        JOIN SeccionDia sd ON s.seccion_id = sd.seccion_id
        JOIN DiaSemana d ON sd.dia_id = d.dia_id
        WHERE m.estudiante_id = p_estudiante_id
        AND s.periodo_academico_id = v_periodo_academico_id
        AND m.estado_matricula_id IN (
            SELECT estado_matricula_id FROM EstadoMatricula 
            WHERE nombre IN ('MATRICULADO', 'EN ESPERA')
        )
        AND d.nombre IN (SELECT nombre FROM DiaSemana ds 
                        JOIN SeccionDia sdd ON ds.dia_id = sdd.dia_id 
                        WHERE sdd.seccion_id = p_seccion_id)
        AND (
            (TIME_TO_SEC(v_seccion_hora_fin) > TIME_TO_SEC(s.hora_inicio) AND
             TIME_TO_SEC(v_seccion_hora_inicio) < TIME_TO_SEC(s.hora_fin))
        )
    ) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'La sección principal traslapa con otra matrícula existente';
    END IF;
    
    -- Si hay laboratorio, verificar sus traslapes
    IF p_laboratorio_id IS NOT NULL AND p_laboratorio_id != 0 THEN
        -- Obtener horarios del laboratorio
        SELECT hora_inicio, hora_fin INTO v_lab_hora_inicio, v_lab_hora_fin 
        FROM Laboratorio WHERE laboratorio_id = p_laboratorio_id;
        
        -- Obtener días del laboratorio
        SELECT GROUP_CONCAT(d.nombre ORDER BY d.nombre SEPARATOR ',') INTO v_lab_dias
        FROM LaboratorioDia ld
        JOIN DiaSemana d ON ld.dia_id = d.dia_id
        WHERE ld.laboratorio_id = p_laboratorio_id;
        
        -- Verificar traslapes del laboratorio con otras secciones/laboratorios
        IF EXISTS (
            SELECT 1 FROM Matricula m
            LEFT JOIN Seccion s ON m.seccion_id = s.seccion_id
            LEFT JOIN Laboratorio l ON m.laboratorio_id = l.laboratorio_id
            LEFT JOIN SeccionDia sd ON s.seccion_id = sd.seccion_id
            LEFT JOIN LaboratorioDia ld ON l.laboratorio_id = ld.laboratorio_id
            LEFT JOIN DiaSemana d ON sd.dia_id = d.dia_id OR ld.dia_id = d.dia_id
            WHERE m.estudiante_id = p_estudiante_id
            AND (s.periodo_academico_id = v_periodo_academico_id OR 
                 l.periodo_academico_id = v_periodo_academico_id)
            AND m.estado_matricula_id IN (
				SELECT estado_matricula_id FROM EstadoMatricula  -- Correcto
					WHERE nombre IN ('MATRICULADO', 'EN ESPERA')
					)
			AND d.nombre IN (SELECT nombre FROM DiaSemana ds 
                            JOIN LaboratorioDia ldd ON ds.dia_id = ldd.dia_id 
                            WHERE ldd.laboratorio_id = p_laboratorio_id)
            AND (
                (TIME_TO_SEC(v_lab_hora_fin) > TIME_TO_SEC(COALESCE(s.hora_inicio, l.hora_inicio)) AND
                 TIME_TO_SEC(v_lab_hora_inicio) < TIME_TO_SEC(COALESCE(s.hora_fin, l.hora_fin)))
            )
        ) THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El laboratorio traslapa con otra matrícula existente';
        END IF;
        
        -- Verificar traslape entre sección principal y laboratorio
        IF EXISTS (
            SELECT 1 FROM DiaSemana d
            WHERE d.nombre IN (SELECT nombre FROM DiaSemana ds 
                              JOIN SeccionDia sdd ON ds.dia_id = sdd.dia_id 
                              WHERE sdd.seccion_id = p_seccion_id)
            AND d.nombre IN (SELECT nombre FROM DiaSemana ds 
                            JOIN LaboratorioDia ldd ON ds.dia_id = ldd.dia_id 
                            WHERE ldd.laboratorio_id = p_laboratorio_id)
            AND (
                (TIME_TO_SEC(v_seccion_hora_fin) > TIME_TO_SEC(v_lab_hora_inicio) AND
                TIME_TO_SEC(v_seccion_hora_inicio) < TIME_TO_SEC(v_lab_hora_fin))
            )
        ) THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'La sección principal y el laboratorio se traslapan en horario';
        END IF;
    END IF;
    
    -- 7. Verificar cupos en la sección principal
    SELECT cupos INTO v_cupos FROM Seccion WHERE seccion_id = p_seccion_id;
    IF v_cupos IS NULL THEN
       SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Sección principal no encontrada';
    END IF;
    
    SELECT COUNT(*) INTO v_totalMatriculados FROM Matricula 
      WHERE seccion_id = p_seccion_id AND estado_matricula_id = (SELECT estado_matricula_id FROM EstadoMatricula WHERE nombre = 'MATRICULADO');
    
    IF v_totalMatriculados >= v_cupos THEN
       SET v_estadoMatricula = 'EN ESPERA';
       SELECT IFNULL(MAX(orden_inscripcion), 0) + 1 INTO v_orden_inscripcion 
         FROM Matricula WHERE seccion_id = p_seccion_id;
    ELSE
       SET v_estadoMatricula = 'MATRICULADO';
    END IF;
    
    -- 8. Insertar matrícula para la sección principal
    INSERT INTO Matricula (estudiante_id, seccion_id, estado_matricula_id, orden_inscripcion, fecha)
      VALUES (p_estudiante_id, p_seccion_id, 
             (SELECT estado_matricula_id FROM EstadoMatricula WHERE nombre = v_estadoMatricula), 
             v_orden_inscripcion, CURDATE());
      
    SET v_matricula_id = LAST_INSERT_ID();
    
    -- 9. Procesar la matrícula en el laboratorio (si la clase tiene laboratorio)
	SELECT tiene_laboratorio, clase_id INTO v_tiene_lab, v_seccion_clase_id 
	FROM Clase 
	WHERE clase_id = (SELECT clase_id FROM Seccion WHERE seccion_id = p_seccion_id);
  
	IF v_tiene_lab = 1 THEN
	IF p_laboratorio_id IS NULL OR p_laboratorio_id = 0 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Se requiere seleccionar un laboratorio para esta clase';
	END IF;
	
	-- Verificar que el laboratorio pertenece a la clase
	IF NOT EXISTS (
	SELECT 1 FROM Laboratorio 
	WHERE laboratorio_id = p_laboratorio_id 
	AND clase_id = v_seccion_clase_id
	) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El laboratorio no pertenece a esta clase';
	END IF;
	
	-- Verificar cupos en el laboratorio
	SELECT cupos INTO v_cupos FROM Laboratorio WHERE laboratorio_id = p_laboratorio_id;
	IF v_cupos IS NULL THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Laboratorio no encontrado';
	END IF;
	
	-- Corrección aquí: usar laboratorio_id en lugar de seccion_id
	SELECT COUNT(*) INTO v_totalMatriculados 
	FROM Matricula 
	WHERE laboratorio_id = p_laboratorio_id
	  AND estado_matricula_id = (SELECT estado_matricula_id FROM EstadoMatricula WHERE nombre = 'MATRICULADO');
	
	IF v_totalMatriculados >= v_cupos THEN
		SET v_estadoMatricula = 'EN ESPERA';
		SELECT IFNULL(MAX(orden_inscripcion), 0) + 1 INTO v_orden_inscripcion 
		FROM Matricula WHERE laboratorio_id = p_laboratorio_id;  -- Corrección aquí también
	ELSE
		SET v_estadoMatricula = 'MATRICULADO';
	END IF;
	
	INSERT INTO Matricula (estudiante_id, laboratorio_id, estado_matricula_id, orden_inscripcion, fecha)
		VALUES (p_estudiante_id, p_laboratorio_id, 
			   (SELECT estado_matricula_id FROM EstadoMatricula WHERE nombre = v_estadoMatricula), 
			   v_orden_inscripcion, CURDATE());
	END IF;
    
    -- 10. Retornar resultados al endpoint
    SELECT v_matricula_id AS matricula_id, v_estadoMatricula AS estado, v_orden_inscripcion AS orden_inscripcion;
END //

DELIMITER ;


DELIMITER //

CREATE PROCEDURE SP_matricular_estudiante(
    IN p_estudiante_id INT,
    IN p_seccion_id INT,
    IN p_tipo_proceso_nombre VARCHAR(50),
    IN p_laboratorio_id INT
)
BEGIN
    -- Declaración de variables
    DECLARE v_periodo_academico_id INT;
    DECLARE v_estadoMatricula VARCHAR(20);
    DECLARE v_orden_inscripcion INT DEFAULT NULL;
    DECLARE v_requisito INT;
    DECLARE v_cumpleRequisito INT;
    DECLARE v_matricula_id INT;
    DECLARE v_tiene_lab BOOLEAN;
    DECLARE v_seccion_clase_id INT;
    DECLARE v_seccion_hora_inicio TIME;
    DECLARE v_seccion_hora_fin TIME;
    DECLARE v_seccion_dias VARCHAR(100);
    DECLARE v_lab_hora_inicio TIME;
    DECLARE v_lab_hora_fin TIME;
    DECLARE v_lab_dias VARCHAR(100);
    DECLARE v_creditos_seccion INT;
    DECLARE v_total_creditos INT;
    DECLARE v_cupos INT;
    DECLARE v_totalMatriculados INT;

    -- Obtener el periodo académico directamente desde la sección
    SELECT periodo_academico_id INTO v_periodo_academico_id 
    FROM Seccion WHERE seccion_id = p_seccion_id;

    IF v_periodo_academico_id IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'No se encontró el periodo académico de la sección';
    END IF;

    -- Verificar que la sección está activa
    IF NOT EXISTS (
        SELECT 1 FROM Seccion 
        WHERE seccion_id = p_seccion_id 
        AND estado_seccion_id = (SELECT estado_seccion_id FROM EstadoSeccion WHERE nombre = 'ACTIVA')
    ) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'La sección no está activa';
    END IF;

    -- Verificar si el estudiante ya aprobó esta clase
    IF EXISTS (
        SELECT 1 FROM HistorialEstudiante h
        JOIN Seccion s ON h.seccion_id = s.seccion_id
        WHERE h.estudiante_id = p_estudiante_id
        AND s.clase_id = (SELECT clase_id FROM Seccion WHERE seccion_id = p_seccion_id)
        AND h.estado_curso_id = (SELECT estado_curso_id FROM EstadoCurso WHERE nombre = 'APROBADA')
    ) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El estudiante ya aprobó esta clase previamente';
    END IF;

    -- 1. Verificar requisitos previos
    SET v_requisito = NULL;
    SET v_cumpleRequisito = 0;

    SELECT prerequisito_clase_id INTO v_requisito FROM ClaseRequisito 
    WHERE clase_id = (SELECT clase_id FROM Seccion WHERE seccion_id = p_seccion_id)
    LIMIT 1;

    IF v_requisito IS NOT NULL THEN
        SELECT COUNT(*) INTO v_cumpleRequisito FROM HistorialEstudiante 
        WHERE estudiante_id = p_estudiante_id 
        AND seccion_id IN (SELECT seccion_id FROM Seccion WHERE clase_id = v_requisito)
        AND estado_curso_id = (SELECT estado_curso_id FROM EstadoCurso WHERE nombre = 'APROBADA');
        IF v_cumpleRequisito = 0 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El estudiante no cumple el requisito previo para la clase';
        END IF;
    END IF;

    -- Verificar que el estudiante no está ya matriculado en esta sección
    IF EXISTS (
        SELECT 1 FROM Matricula 
        WHERE estudiante_id = p_estudiante_id 
        AND seccion_id = p_seccion_id
        AND estado_matricula_id IN (
            SELECT estado_matricula_id FROM EstadoMatricula 
            WHERE nombre IN ('MATRICULADO', 'EN ESPERA')
        )
    ) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El estudiante ya está matriculado en esta sección';
    END IF;

    -- Verificar créditos
    SELECT c.creditos INTO v_creditos_seccion 
    FROM Clase c
    JOIN Seccion s ON c.clase_id = s.clase_id
    WHERE s.seccion_id = p_seccion_id;

    SELECT IFNULL(SUM(c.creditos), 0) INTO v_total_creditos
    FROM Matricula m
    JOIN Seccion s ON m.seccion_id = s.seccion_id
    JOIN Clase c ON s.clase_id = c.clase_id
    WHERE m.estudiante_id = p_estudiante_id
    AND s.periodo_academico_id = v_periodo_academico_id
    AND m.estado_matricula_id IN (
        SELECT estado_matricula_id FROM EstadoMatricula 
        WHERE nombre IN ('MATRICULADO', 'EN ESPERA')
    );

    IF (v_total_creditos + v_creditos_seccion) > 25 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'La matrícula excede el límite de 25 créditos';
    END IF;

    -- Verificar traslapes
    SELECT hora_inicio, hora_fin INTO v_seccion_hora_inicio, v_seccion_hora_fin 
    FROM Seccion WHERE seccion_id = p_seccion_id;

    SELECT GROUP_CONCAT(d.nombre ORDER BY d.nombre SEPARATOR ',') INTO v_seccion_dias
    FROM SeccionDia sd
    JOIN DiaSemana d ON sd.dia_id = d.dia_id
    WHERE sd.seccion_id = p_seccion_id;

    IF EXISTS (
        SELECT 1 FROM Matricula m
        JOIN Seccion s ON m.seccion_id = s.seccion_id
        JOIN SeccionDia sd ON s.seccion_id = sd.seccion_id
        JOIN DiaSemana d ON sd.dia_id = d.dia_id
        WHERE m.estudiante_id = p_estudiante_id
        AND s.periodo_academico_id = v_periodo_academico_id
        AND m.estado_matricula_id IN (
            SELECT estado_matricula_id FROM EstadoMatricula 
            WHERE nombre IN ('MATRICULADO', 'EN ESPERA')
        )
        AND d.nombre IN (
            SELECT nombre FROM DiaSemana ds 
            JOIN SeccionDia sdd ON ds.dia_id = sdd.dia_id 
            WHERE sdd.seccion_id = p_seccion_id
        )
        AND (
            (TIME_TO_SEC(v_seccion_hora_fin) > TIME_TO_SEC(s.hora_inicio) AND
             TIME_TO_SEC(v_seccion_hora_inicio) < TIME_TO_SEC(s.hora_fin))
        )
    ) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'La sección traslapa con otra matrícula existente';
    END IF;

    -- Cupo siempre se considera como "EN ESPERA"
    SET v_estadoMatricula = 'EN ESPERA';
    SELECT IFNULL(MAX(orden_inscripcion), 0) + 1 INTO v_orden_inscripcion 
    FROM Matricula WHERE seccion_id = p_seccion_id;

    -- Insertar matrícula
    INSERT INTO Matricula (estudiante_id, seccion_id, estado_matricula_id, orden_inscripcion, fecha)
    VALUES (p_estudiante_id, p_seccion_id, 
        (SELECT estado_matricula_id FROM EstadoMatricula WHERE nombre = v_estadoMatricula), 
        v_orden_inscripcion, CURDATE());

    SET v_matricula_id = LAST_INSERT_ID();

    -- Procesar laboratorio si aplica
    SELECT tiene_laboratorio, clase_id INTO v_tiene_lab, v_seccion_clase_id 
    FROM Clase 
    WHERE clase_id = (SELECT clase_id FROM Seccion WHERE seccion_id = p_seccion_id);

    IF v_tiene_lab = 1 THEN
        IF p_laboratorio_id IS NULL OR p_laboratorio_id = 0 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Se requiere seleccionar un laboratorio para esta clase';
        END IF;

        IF NOT EXISTS (
            SELECT 1 FROM Laboratorio 
            WHERE laboratorio_id = p_laboratorio_id 
            AND clase_id = v_seccion_clase_id
        ) THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El laboratorio no pertenece a esta clase';
        END IF;

        SELECT hora_inicio, hora_fin INTO v_lab_hora_inicio, v_lab_hora_fin 
        FROM Laboratorio WHERE laboratorio_id = p_laboratorio_id;

        SELECT GROUP_CONCAT(d.nombre ORDER BY d.nombre SEPARATOR ',') INTO v_lab_dias
        FROM LaboratorioDia ld
        JOIN DiaSemana d ON ld.dia_id = d.dia_id
        WHERE ld.laboratorio_id = p_laboratorio_id;

        IF EXISTS (
            SELECT 1 FROM DiaSemana d
            WHERE d.nombre IN (
                SELECT nombre FROM DiaSemana ds 
                JOIN SeccionDia sdd ON ds.dia_id = sdd.dia_id 
                WHERE sdd.seccion_id = p_seccion_id
            )
            AND d.nombre IN (
                SELECT nombre FROM DiaSemana ds 
                JOIN LaboratorioDia ldd ON ds.dia_id = ldd.dia_id 
                WHERE ldd.laboratorio_id = p_laboratorio_id
            )
            AND (
                (TIME_TO_SEC(v_seccion_hora_fin) > TIME_TO_SEC(v_lab_hora_inicio) AND
                TIME_TO_SEC(v_seccion_hora_inicio) < TIME_TO_SEC(v_lab_hora_fin))
            )
        ) THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'La sección y el laboratorio se traslapan';
        END IF;

        SET v_estadoMatricula = 'EN ESPERA';
        SELECT IFNULL(MAX(orden_inscripcion), 0) + 1 INTO v_orden_inscripcion 
        FROM Matricula WHERE laboratorio_id = p_laboratorio_id;

        INSERT INTO Matricula (estudiante_id, laboratorio_id, estado_matricula_id, orden_inscripcion, fecha)
        VALUES (p_estudiante_id, p_laboratorio_id, 
            (SELECT estado_matricula_id FROM EstadoMatricula WHERE nombre = v_estadoMatricula), 
            v_orden_inscripcion, CURDATE());
    END IF;

    -- Retornar resultados
    SELECT v_matricula_id AS matricula_id, v_estadoMatricula AS estado, v_orden_inscripcion AS orden_inscripcion;
END //

DELIMITER ;




DELIMITER //

CREATE PROCEDURE SP_actualizarListaEspera(
    IN p_seccion_id INT
)
BEGIN
    DECLARE v_matricula_id INT DEFAULT NULL;
    DECLARE v_capacidad INT;
    DECLARE v_matriculados INT;
    
    -- Obtener la capacidad (cupos) de la sección
    SELECT cupos INTO v_capacidad FROM Seccion WHERE seccion_id = p_seccion_id;
    
    -- Si no se encuentra la capacidad de la sección, lanzar un error
    IF v_capacidad IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Sección no encontrada o sin capacidad definida';
    END IF;
    
    -- Contar los estudiantes matriculados (estado = 'MATRICULADO')
    SELECT COUNT(*) INTO v_matriculados 
    FROM Matricula 
    WHERE seccion_id = p_seccion_id 
      AND estado_matricula_id = (SELECT estado_matricula_id FROM EstadoMatricula WHERE nombre = 'MATRICULADO');
    
    -- Si hay vacante (es decir, la cantidad matriculada es menor que la capacidad)
    IF v_matriculados < v_capacidad THEN
        -- Selecciona el primer estudiante en lista de espera (el de menor orden_inscripcion)
        SELECT matricula_id
        INTO v_matricula_id
        FROM Matricula
        WHERE seccion_id = p_seccion_id
          AND estado_matricula_id = (SELECT estado_matricula_id FROM EstadoMatricula WHERE nombre = 'EN ESPERA')
        ORDER BY orden_inscripcion ASC
        LIMIT 1;
    
        -- Si se encontró algún estudiante en espera, se promueve a MATRICULADO
        IF v_matricula_id IS NOT NULL THEN
            UPDATE Matricula
            SET estado_matricula_id = (SELECT estado_matricula_id FROM EstadoMatricula WHERE nombre = 'MATRICULADO'),
                orden_inscripcion = NULL
            WHERE matricula_id = v_matricula_id;
        END IF;
    END IF;
    
    -- Recalcular el orden de inscripción para todos los estudiantes en espera,
    -- de modo que queden numerados consecutivamente (1, 2, 3, ...)
    SET @new_order := 0;
    UPDATE Matricula
    SET orden_inscripcion = (@new_order := @new_order + 1)
    WHERE seccion_id = p_seccion_id
      AND estado_matricula_id = (SELECT estado_matricula_id FROM EstadoMatricula WHERE nombre = 'EN ESPERA')
    ORDER BY orden_inscripcion;
    
END //

DELIMITER ;


DELIMITER //

CREATE PROCEDURE SP_matricular_estudiante_adiciones_cancelaciones(
    IN p_estudiante_id INT,
    IN p_seccion_id INT,
    IN p_tipo_proceso VARCHAR(50),
    IN p_lab_seccion_id INT  -- ID del laboratorio seleccionado (debe ser no nulo si la clase tiene laboratorio)
)
BEGIN
    -- Declaración de variables para la matrícula principal
    DECLARE v_proceso_id INT;
    DECLARE v_periodo_academico_id INT;
    DECLARE v_fecha_inicio DATETIME;
    DECLARE v_estado_proceso_id INT;
    DECLARE v_cupos INT;
    DECLARE v_totalMatriculados INT;
    DECLARE v_estadoMatricula VARCHAR(20);
    DECLARE v_orden_inscripcion INT DEFAULT NULL;
    DECLARE v_requisito INT;
    DECLARE v_cumpleRequisito INT;
    DECLARE v_matricula_id INT;
    
    -- Variables para la matrícula del laboratorio
    DECLARE v_lab_cupos INT;
    DECLARE v_lab_totalMatriculados INT;
    DECLARE v_lab_estadoMatricula VARCHAR(20);
    DECLARE v_lab_orden_inscripcion INT DEFAULT NULL;
    DECLARE v_lab_clase_id INT;
    DECLARE v_seccion_clase_id INT;
    DECLARE v_tiene_lab BOOLEAN;
    
    -- Verificar que el tipo de proceso sea ADICIONES_CANCELACIONES
    IF UPPER(p_tipo_proceso) <> 'ADICIONES_CANCELACIONES' THEN
       SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El tipo de proceso debe ser ADICIONES_CANCELACIONES';
    END IF;

    -- 1. Obtener proceso activo para ADICIONES_CANCELACIONES
    SELECT proceso_id, periodo_academico_id, fecha_inicio, estado_proceso_id
      INTO v_proceso_id, v_periodo_academico_id, v_fecha_inicio, v_estado_proceso_id
    FROM ProcesoMatricula
    WHERE UPPER(tipo_proceso) = 'ADICIONES_CANCELACIONES'
      AND estado_proceso_id = (SELECT estado_proceso_id FROM EstadoProceso WHERE nombre = 'ACTIVO')
    LIMIT 1;
    
    IF v_proceso_id IS NULL THEN
       SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'No hay proceso activo para ADICIONES_CANCELACIONES';
    END IF;
    
    -- 2. Verificar requisitos previos
    SET v_requisito = NULL;
    SET v_cumpleRequisito = 0;
    
    SELECT prerequisito_clase_id INTO v_requisito 
      FROM ClaseRequisito 
      WHERE clase_id = (SELECT clase_id FROM Seccion WHERE seccion_id = p_seccion_id)
      LIMIT 1;
      
    IF v_requisito IS NOT NULL THEN
       SELECT COUNT(*) INTO v_cumpleRequisito 
         FROM HistorialEstudiante 
         WHERE estudiante_id = p_estudiante_id 
           AND seccion_id IN (SELECT seccion_id FROM Seccion WHERE clase_id = v_requisito)
           AND estado_curso_id = (SELECT estado_curso_id FROM EstadoCurso WHERE nombre = 'APROBADA');
       IF v_cumpleRequisito = 0 THEN
          SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El estudiante no cumple el requisito previo para la clase';
       END IF;
    END IF;
    
    -- 3. Verificar traslapes horarios para la sección principal
    IF EXISTS (
       SELECT 1 FROM Seccion s
       INNER JOIN Matricula m ON s.seccion_id = m.seccion_id
       WHERE m.estudiante_id = p_estudiante_id
         AND s.periodo_academico_id = v_periodo_academico_id
         AND m.estado_matricula_id IN (SELECT estado_matricula_id FROM EstadoMatricula WHERE nombre IN ('MATRICULADO', 'EN ESPERA'))
         AND (TIME_TO_SEC((SELECT hora_fin FROM Seccion WHERE seccion_id = p_seccion_id)) > TIME_TO_SEC(s.hora_inicio)
              AND TIME_TO_SEC((SELECT hora_inicio FROM Seccion WHERE seccion_id = p_seccion_id)) < TIME_TO_SEC(s.hora_fin))
    ) THEN
       SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El horario de la sección principal traslapa con otra matrícula';
    END IF;
    
    -- 4. Verificar cupos en la sección principal
    SELECT cupos INTO v_cupos FROM Seccion WHERE seccion_id = p_seccion_id;
    IF v_cupos IS NULL THEN
       SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Sección principal no encontrada';
    END IF;
    
    SELECT COUNT(*) INTO v_totalMatriculados 
      FROM Matricula 
      WHERE seccion_id = p_seccion_id AND estado_matricula_id = (SELECT estado_matricula_id FROM EstadoMatricula WHERE nombre = 'MATRICULADO');
    
    IF v_totalMatriculados >= v_cupos THEN
       SET v_estadoMatricula = 'EN ESPERA';
       SELECT IFNULL(MAX(orden_inscripcion), 0) + 1 INTO v_orden_inscripcion 
         FROM Matricula WHERE seccion_id = p_seccion_id;
    ELSE
       SET v_estadoMatricula = 'MATRICULADO';
    END IF;
    
    -- 5. Insertar matrícula para la sección principal
    INSERT INTO Matricula (estudiante_id, seccion_id, estado_matricula_id, orden_inscripcion)
      VALUES (p_estudiante_id, p_seccion_id, (SELECT estado_matricula_id FROM EstadoMatricula WHERE nombre = v_estadoMatricula), v_orden_inscripcion);
      
    SET v_matricula_id = LAST_INSERT_ID();
    
    -- 6. Procesar la matrícula en el laboratorio (si la clase tiene laboratorio)
    SELECT tiene_laboratorio, clase_id INTO v_tiene_lab, v_seccion_clase_id 
      FROM Clase 
      WHERE clase_id = (SELECT clase_id FROM Seccion WHERE seccion_id = p_seccion_id);
      
    IF v_tiene_lab = 1 THEN
        IF p_lab_seccion_id IS NULL OR p_lab_seccion_id = 0 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Se requiere seleccionar un laboratorio para esta clase';
        END IF;
        
        -- Verificación del laboratorio seleccionado
        SELECT clase_id INTO v_lab_clase_id FROM Seccion WHERE seccion_id = p_lab_seccion_id;
        IF v_lab_clase_id <> v_seccion_clase_id THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El laboratorio seleccionado no corresponde a la misma clase';
        END IF;
        
        -- Validación de horarios del laboratorio
        IF EXISTS (
           SELECT 1 FROM Seccion s
           INNER JOIN Matricula m ON s.seccion_id = m.seccion_id
           WHERE m.estudiante_id = p_estudiante_id
             AND s.periodo_academico_id = v_periodo_academico_id
             AND m.estado_matricula_id IN (SELECT estado_matricula_id FROM EstadoMatricula WHERE nombre IN ('MATRICULADO', 'EN ESPERA'))
             AND (TIME_TO_SEC((SELECT hora_fin FROM Seccion WHERE seccion_id = p_lab_seccion_id)) > TIME_TO_SEC(s.hora_inicio)
                  AND TIME_TO_SEC((SELECT hora_inicio FROM Seccion WHERE seccion_id = p_lab_seccion_id)) < TIME_TO_SEC(s.hora_fin))
        ) THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El horario del laboratorio traslapa con otra matrícula';
        END IF;
        
        -- Validación del horario de la sección principal con el laboratorio
        IF EXISTS (
           SELECT 1 FROM Seccion s
           WHERE s.seccion_id = p_seccion_id
             AND TIME_TO_SEC((SELECT hora_fin FROM Seccion WHERE seccion_id = p_lab_seccion_id)) > TIME_TO_SEC(s.hora_inicio)
             AND TIME_TO_SEC((SELECT hora_inicio FROM Seccion WHERE seccion_id = p_lab_seccion_id)) < TIME_TO_SEC(s.hora_fin)
        ) THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El horario del laboratorio traslapa con el de la sección principal';
        END IF;
        
        SELECT cupos INTO v_lab_cupos FROM Seccion WHERE seccion_id = p_lab_seccion_id;
        IF v_lab_cupos IS NULL THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Laboratorio no encontrado';
        END IF;
        SELECT COUNT(*) INTO v_lab_totalMatriculados 
          FROM Matricula WHERE seccion_id = p_lab_seccion_id AND estado_matricula_id = (SELECT estado_matricula_id FROM EstadoMatricula WHERE nombre = 'MATRICULADO');
        IF v_lab_totalMatriculados >= v_lab_cupos THEN
            SET v_lab_estadoMatricula = 'EN ESPERA';
            SELECT IFNULL(MAX(orden_inscripcion), 0) + 1 INTO v_lab_orden_inscripcion 
              FROM Matricula WHERE seccion_id = p_lab_seccion_id;
        ELSE
            SET v_lab_estadoMatricula = 'MATRICULADO';
        END IF;
        
        INSERT INTO Matricula (estudiante_id, seccion_id, estado_matricula_id, orden_inscripcion)
            VALUES (p_estudiante_id, p_lab_seccion_id, v_lab_estadoMatricula, v_lab_orden_inscripcion);
    END IF;
    
    -- 7. Retornar resultados al endpoint
    SELECT v_matricula_id AS matricula_id, v_estadoMatricula AS estado, v_orden_inscripcion AS orden_inscripcion;
END //

DELIMITER ;



DELIMITER //
CREATE PROCEDURE SP_actualizar_estado_carrera(
    IN p_aspirante_id INT,
    IN p_carrera_id INT,
    IN p_aprobado BOOLEAN
)
BEGIN
    DECLARE v_estado_id INT;
    
    -- Obtener ID del estado
    IF p_aprobado THEN
        SELECT estado_aspirante_carrera_id INTO v_estado_id
        FROM EstadoAspiranteCarrera
        WHERE nombre = 'APROVADO';
    ELSE
        SELECT estado_aspirante_carrera_id INTO v_estado_id
        FROM EstadoAspiranteCarrera
        WHERE nombre = 'NO_APROVADO';
    END IF;
    
    -- Insertar o actualizar estado
    INSERT INTO AspiranteCarrera 
    (aspirante_id, carrera_id, estado_aspirante_carrera_id)
    VALUES (p_aspirante_id, p_carrera_id, v_estado_id)
    ON DUPLICATE KEY UPDATE 
    estado_aspirante_carrera_id = v_estado_id;
END //
DELIMITER ;

DELIMITER // 
CREATE PROCEDURE SP_evaluar_aprobacion_carrera(
    IN p_aspirante_id INT,
    IN p_carrera_id INT,
    OUT p_aprobado BOOLEAN
)
BEGIN
    DECLARE examenes_faltantes INT;
    
    SELECT COUNT(*) INTO examenes_faltantes
    FROM CarreraExamen ce
    WHERE ce.carrera_id = p_carrera_id
    AND NOT EXISTS (
        SELECT 1 
        FROM ResultadoExamen re
        JOIN TipoExamen te ON re.tipo_examen_id = te.tipo_examen_id
        WHERE re.aspirante_id = p_aspirante_id
        AND re.carrera_id = p_carrera_id
        AND re.tipo_examen_id = ce.tipo_examen_id
        AND re.calificacion >= te.nota_minima
    );
    
    SET p_aprobado = (examenes_faltantes = 0);
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE SP_registrar_resultado_examen(
    IN p_aspirante_id INT,
    IN p_tipo_examen_id INT,
    IN p_carrera_id INT,
    IN p_calificacion DECIMAL(4,2),
    OUT p_resultado_id INT
)
BEGIN
    DECLARE v_nota_minima DECIMAL(6,2);
    DECLARE v_resultado_tipo_id INT;
    DECLARE v_examen_pertenece INT DEFAULT 0;
    
    -- Verificar que el examen pertenezca a la carrera
    SELECT COUNT(*) INTO v_examen_pertenece
    FROM CarreraExamen
    WHERE carrera_id = p_carrera_id AND tipo_examen_id = p_tipo_examen_id;
    
    IF v_examen_pertenece = 0 THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'El examen no pertenece a la carrera especificada';
    ELSE
        -- Obtener nota mínima para este examen en esta carrera
        SELECT nota_minima INTO v_nota_minima 
        FROM TipoExamen 
        WHERE tipo_examen_id = p_tipo_examen_id;
        
        -- Determinar resultado
        IF p_calificacion >= v_nota_minima THEN
            SET v_resultado_tipo_id = 1; -- APROBADO
        ELSE
            SET v_resultado_tipo_id = 2; -- NO APROBADO
        END IF;
        
        -- Insertar el resultado (sin ON DUPLICATE KEY porque ahora tenemos clave autoincremental)
        INSERT INTO ResultadoExamen 
        (aspirante_id, tipo_examen_id, carrera_id, fecha_examen, calificacion, resultado_tipo_id)
        VALUES (p_aspirante_id, p_tipo_examen_id, p_carrera_id, CURDATE(), p_calificacion, v_resultado_tipo_id);
        
        SET p_resultado_id = LAST_INSERT_ID();
    END IF;
END //
DELIMITER ;

-- Obtener tipo de examen
DELIMITER //
CREATE PROCEDURE SP_obtener_tipo_examen(
    IN p_nombre VARCHAR(100),
    OUT p_tipo_examen_id INT,
    OUT p_nota_minima DECIMAL(6,2)
)
BEGIN
    SELECT tipo_examen_id, nota_minima INTO p_tipo_examen_id, p_nota_minima
    FROM TipoExamen 
    WHERE nombre = p_nombre;
END //
DELIMITER ;

-- Obtener exámenes de un aspirante
DELIMITER //
CREATE PROCEDURE SP_obtener_examenes_aspirante(
    IN p_aspirante_id INT
)
BEGIN
    SELECT re.tipo_examen_id, te.nombre, re.calificacion, te.nota_minima
    FROM ResultadoExamen re
    JOIN TipoExamen te ON re.tipo_examen_id = te.tipo_examen_id
    WHERE re.aspirante_id = p_aspirante_id;
END //
DELIMITER ;

-- Verificar si examen pertenece a carrera
DELIMITER //
CREATE PROCEDURE SP_es_examen_de_carrera(
    IN p_tipo_examen_id INT,
    IN p_carrera_id INT,
    OUT p_pertenece BOOLEAN
)
BEGIN
    DECLARE v_count INT;
    
    SELECT COUNT(*) INTO v_count
    FROM CarreraExamen
    WHERE tipo_examen_id = p_tipo_examen_id
    AND carrera_id = p_carrera_id;
    
    SET p_pertenece = (v_count > 0);
END //
DELIMITER ;


--EVENTOS

SET GLOBAL event_scheduler = ON;

CREATE EVENT IF NOT EXISTS EV_actualizar_estado_periodo
ON SCHEDULE EVERY 1 MINUTE
DO
   UPDATE PeriodoAcademico
   SET estado = 'INACTIVO'
   WHERE fecha_fin <= NOW() AND estado = 'ACTIVO';
   
   
   

CREATE EVENT IF NOT EXISTS EV_actualizar_estado_proceso_matricula
ON SCHEDULE EVERY 1 MINUTE
DO
   UPDATE ProcesoMatricula
   SET estado = 'INACTIVO'
   WHERE fecha_fin < NOW() AND estado = 'ACTIVO';
   
  
  
  
CREATE EVENT IF NOT EXISTS EV_actualizar_estado_procesos_excepcionales
ON SCHEDULE EVERY 1 MINUTE
DO
   UPDATE ProcesosExcepcionales
   SET estado = 'INACTIVO'
   WHERE fecha_fin < NOW() AND estado = 'ACTIVO';



Expresion regular validacion Identidades

/*
((01(0[1-8]))|(02(0[1-9]|10))|(03(0[1-9]|1[0-9]|2[01]))|(04(0[1-9]|1[0-9]|2[0-3]))|(05(0[1-9]|1[0-2]))|(06(0[1-9]|1[0-6]))|(07(0[1-9]|1[0-9]))|(08(0[1-9]|1[0-9]|2[0-8]))|(09(0[1-6]))|(10(0[1-9]|1[0-7]))|(11(0[1-4]))|(12(0[1-9]|1[0-9]))|(13(0[1-9]|1[0-9]|2[0-8]))|(14(0[1-9]|1[0-6]))|(15(0[1-9]|1[0-9]|2[0-3]))|(16(0[1-9]|1[0-9]|2[0-8]))|(17(0[1-9]))|(18(0[1-9]|1[0-1])))-((19[4-9][0-9])|(20[0-9]{2}))-([0-9]{5}$)
*/

Expresion regular validacion Numeros de telefono

/*
(\+504|504|\(\+504\)|\+\(504\))?[-]?([369][0-9]{3})[-]?([0-9]{4})
*/
